# An attempt at solving a puzzle
query Guess($puzzle_id: uuid!, $solution: String!) {
  fail: puzzles_by_pk(puzzle_id: $puzzle_id) {
    fail_route
  }
  success: puzzles(
    where: { puzzle_id: { _eq: $puzzle_id }, solution: { _eq: $solution } }
  ) {
    success_route
    final_step
  }
}

# Information needed for a puzzle to render
query PuzzleInfoByLanding($landing: String!) {
  puzzles(where: { landing_route: { _eq: $landing } }) {
    simple_name
    solution_char_count
    puzzle_id
    input_type
    fail_message
    landing_message
  }
}

query PuzzleInfoBySuccess($success: String!) {
  puzzles(where: { success_route: { _eq: $success } }) {
    simple_name
    puzzle_id
    success_message
    nft {
      tokenId
      nft_metadatum {
        cloudinary_id
      }
    }
  }
}

# Used to prebuild all puzzle routes
query AllLandingRoutes {
  puzzles {
    landing_route
  }
}
query AllSuccessRoutes {
  puzzles {
    success_route
  }
}

# A user submits against a puzzle id, but we need to check that the user's jwt
# claims include the success route for the puzzle id
query UserPuzzlesInSubmitted($puzzleId: uuid, $puzzleRoutes: [String!]) {
  puzzles(
    where: {
      puzzle_id: { _eq: $puzzleId }
      _and: { success_route: { _in: $puzzleRoutes } }
    }
  ) {
    success_route
  }
}
# A user submits a form after completing a puzzle
mutation UserSubmission(
  $puzzle_id: uuid!
  $user_id: uuid!
  $form_data: jsonb
  $email: String
) {
  insert_submissions_one(
    object: { user_id: $user_id, puzzle_id: $puzzle_id, form_data: $form_data }
  ) {
    user_id
    puzzle_id
    form_data
  }
  update_users_by_pk(
    pk_columns: { user_id: $user_id }
    _set: { email: $email }
  ) {
    user_id
    email
  }
}

# Create/update ANONYMOUS users, do not touch nonce nor wallet here
mutation UpsertUser($userId: uuid) {
  insert_users(
    objects: { user_id: $userId }
    on_conflict: { constraint: users_pkey, update_columns: [] }
  ) {
    returning {
      user_id
    }
  }
}

# nonce is any random string
mutation AddWalletToUser(
  $userId: uuid!
  $publicAddress: String!
  $nonce: String!
) {
  user: update_users_by_pk(
    pk_columns: { user_id: $userId }
    _set: { public_address: $publicAddress, nonce: $nonce }
  ) {
    nonce
  }
}

query UserByPublicAddress($publicAddress: String!) {
  submissions(where: { user: { public_address: { _eq: $publicAddress } } }) {
    puzzle {
      success_route
    }
  }
  users(where: { public_address: { _eq: $publicAddress } }) {
    user_id
    nonce
  }
}

# When an anon user signs in with wallet, we want to migrate anon submissions to them
query MigrateUserSubmissions($fromUser: uuid, $toUser: uuid) {
  fromUser: submissions(where: { user_id: { _eq: $fromUser } }) {
    form_data
    puzzle_id
  }
  toUser: submissions(where: { user_id: { _eq: $toUser } }) {
    form_data
    puzzle_id
  }
}

query PublicPuzzles($limit: Int = 10, $offset: Int = 0) {
  puzzles(
    limit: $limit
    offset: $offset
    where: { list_pubicly: { _eq: true } }
    order_by: { sort_weight: asc, simple_name: asc }
  ) {
    puzzle_id
    landing_route
    simple_name
    nft {
      nft_metadatum {
        cloudinary_id
      }
    }
  }
  count: puzzles_aggregate(where: { list_pubicly: { _eq: true } }) {
    aggregate {
      count
    }
  }
}

query GetNftIdByPuzzleName($puzzleName: String) {
  nfts(where: { puzzle: { simple_name: { _eq: $puzzleName } } }) {
    tokenId
  }
}
query GetNftIdByPuzzleSuccessRoute($successRoute: String) {
  nfts(where: { puzzle: { success_route: { _eq: $successRoute } } }) {
    tokenId
  }
}
query GetAllNftClaims {
  nfts {
    puzzle {
      success_route
    }
  }
}

query GetPuzzleInfoByNftId($nftId: Int!) {
  puzzles(where: { nft: { tokenId: { _eq: $nftId } } }) {
    simple_name
    puzzle_id
    success_route
  }
}

query GetAllPacks {
  packs {
    simple_name
  }
}

query GetPuzzlesByPack($packName: String!) {
  puzzles(
    where: { pack_puzzles: { pack: { simple_name: { _eq: $packName } } } }
  ) {
    simple_name
    landing_route
    puzzle_id
    nft {
      tokenId
      nft_metadatum {
        cloudinary_id
      }
    }
  }
  pack: packs(where: { simple_name: { _eq: $packName } }) {
    pack_name
    nftId
  }
}

query NftMetadata($nftId: Int!, $contractName: String!) {
  nft_metadata_by_pk(contract_name: $contractName, token_id: $nftId) {
    contract_name
    data
    token_id
  }
}
